# **SRT-4 除法算法设计与实现逻辑**

## **1\. 概述**

SRT（Sweeney, Robertson, and Tocher）除法算法属于数字递归（Digit Recurrence）类算法，广泛应用于高性能浮点运算单元（FPU）中。SRT-4表示该算法采用基数4（Radix-4），即每次迭代生成2位商。相较于传统的恢复余数法（Restoring）或不恢复余数法（Non-Restoring），SRT算法的核心优势在于引入了**冗余符号位集合（Redundant Signed-Digit, RSD）**，使得商位选择过程不再依赖于全精度的部分余数比较，从而显著缩短了关键路径延迟。

## **2\. 数学原理**

### **2.1 递归公式**

SRT-4除法的核心迭代公式如下：

$$P\_{j+1} \= r \\cdot P\_j \- q\_{j+1} \\cdot D$$  
其中：

* $P\_j$：第 $j$ 次迭代的部分余数（Partial Remainder）。  
* $P\_0$：初始部分余数，即被除数。  
* $r$：基数，对于SRT-4， $r=4$。  
* $q\_{j+1}$：第 $j+1$ 次选取的商位。  
* $D$：除数。

### **2.2 冗余商位集**

SRT-4通常采用最小冗余集合：

$$q\_k \\in \\{-2, \-1, 0, 1, 2\\}$$  
使用该集合的优势在于：

1. **生成简单**：$q \\cdot D$ 的计算仅涉及简单的移位（$\\times 2$）和取反操作，无需复杂的乘法器。  
2. **容错性**：由于集合的冗余性（例如，部分余数在一定范围内既可以选 $q=1$ 也可以选 $q=2$），允许商位选择逻辑仅使用部分余数和除数的高几位进行估算，而不必进行全加法器比较。

### **2.3 收敛条件**

为了保证迭代收敛，部分余数必须限制在一定范围内。对于最大商位 $a=2$ 和基数 $r=4$，冗余因子 $\\rho$ 定义为：

$$\\rho \= \\frac{a}{r-1} \= \\frac{2}{4-1} \= \\frac{2}{3}$$  
部分余数 $P\_j$ 必须满足：

$$|P\_j| \\le \\rho \\cdot D \= \\frac{2}{3} D$$

## **3\. 硬件架构设计逻辑**

SRT-4除法器的硬件实现主要包含以下核心模块：

### **3.1 预处理与归一化 (Normalization)**

SRT算法要求除数 $D$ 必须归一化到范围 $\[0.5, 1)$ (对于定点小数) 或最高位为1 (对于整数)。这确保了商位选择的P-D图的有效性。

* **逻辑**：检测除数前导零个数 (Leading Zero Count, LZC)，将除数和被除数左移相应位数。

### **3.2 商位选择逻辑 (QDS)**

这是SRT算法的关键路径，直接决定了电路的时序性能。QDS模块本质上是一个查找表或组合逻辑电路，其设计核心在于确定部分余数与除数比值的判定边界。

#### **3.2.1 P-D 图与选择区间**

商位 $q\_k$ 的选择取决于移位后的部分余数 $4P\_{k-1}$ 与除数 $D$ 的关系。对于每个可能的商位 $k \\in \\{-2, \-1, 0, 1, 2\\}$，存在一个合法的选择区间 $\[L\_k, U\_k\]$，使得在该区间内选择 $q=k$ 能够保证下一轮部分余数收敛。

根据收敛条件 $|P\_{next}| \\le \\rho D$，推导出区间边界如下：

* **上限** $U\_k$：$(k \+ \\rho)D \= (k \+ \\frac{2}{3})D$  
* **下限** $L\_k$：$(k \- \\rho)D \= (k \- \\frac{2}{3})D$

由于相邻区间的重叠（例如 $U\_0 \> L\_1$），形成了重叠区域（Overlap Region）。该区域的存在允许使用截断精度的变量进行决策。

#### **3.2.2 阈值离散化与查找表常量**

为了实现低延迟硬件设计，必须避免全精度比较。工程实现采用部分余数的高位截断值 $\\hat{P}$ 和除数的高位截断值 $\\hat{D}$ 作为QDS输入。

1. **输入位宽定义**  
   * $\\hat{P}$：通常取高7至8位（包含符号位，且若使用CSA需先经过4位CPA压缩）。  
   * $\\hat{D}$：通常取高4位（不含前导1，即 $\\delta \= d\_{-2}d\_{-3}d\_{-4}d\_{-5}$）。  
2. 阶梯状阈值设计  
   理论上的比较阈值 $m\_k(D)$ 是除数 $D$ 的线性函数（如 $0.5D, 1.5D$）。在离散化P-D图中，这些线性阈值被近似为阶梯函数。对于每个 $\\hat{D}$ 定义的离散区间，设计一组固定的比较常量 $m\_k(\\hat{D})$。  
   阈值常量表构建原则：  
   对于给定的除数区间 $D \\in \[D\_{min}, D\_{max})$，选择常量 $m\_k$ 需满足：$$\\max(L\_k) \\le m\_k \\le \\min(U\_{k-1})$$  
   这意味着分割线必须位于相邻商位选择区间的重叠部分内，且在任何 $D$ 值下均有效。  
3. 常量表示例  
   下表展示了针对不同除数高位索引（$\\delta$）的典型比较常量设计（数值单位为最低位LSB或者分数形式）：

| 除数前缀 $\\hat{D}$ (Index) | $m\_{2} (q=2|1)$ | $m\_{1} (q=1|0)$ | $m\_{0} (q=0|-1)$ | $m\_{-1} (q=-1|-2)$ |  
| :--- | :--- | :--- | :--- | :--- |  
| 0000 ($D \\approx 0.5$) | 12 | 4 | \-3 | \-11 |  
| 0100 ($D \\approx 0.625$) | 15 | 5 | \-4 | \-14 |  
| 1000 ($D \\approx 0.75$) | 18 | 6 | \-5 | \-17 |  
| 1111 ($D \\to 1.0$) | 24 | 8 | \-7 | \-23 |  
*注：表中数值仅为示意，实际硬件常数取决于* $\\hat{P}$ *的具体定点位置及截断误差分析。*

4. 逻辑实现  
   硬件仅需比较 $\\hat{P}$ 与当前 $\\hat{D}$ 对应的常量 $m\_k$：  
   * 若 $\\hat{P} \\ge m\_2(\\hat{D})$，则 $q=2$  
   * 若 $m\_1(\\hat{D}) \\le \\hat{P} \< m\_2(\\hat{D})$，则 $q=1$  
   * 依此类推。

由于比较常量较少且位宽较小，该逻辑通常通过小型多路复用器（MUX）和比较器树或直接综合为积之和（Sum-of-Products）逻辑门阵列实现。

### **3.3 部分余数更新逻辑**

$$P\_{next} \= 4 P\_{curr} \- q \\cdot D$$  
该步骤通常使用 **进位保存加法器 (Carry-Save Adder, CSA)** 实现，以避免产生长进位链。

* 若采用CSA，部分余数将以 (Sum, Carry) 对的形式存储。  
* 此时QDS的输入需要将Sum和Carry的高几位进行传播相加（CPA）以获取 $\\hat{P}$。

### **3.4 在线商转换 (On-the-Fly Conversion)**

由于 $q\_k$ 包含负数，最终商不能简单拼接。需要实时维护两个寄存器 $Q$ 和 $QM$：

* $Q$：当前累积商。  
* $QM$：$Q \- 1$ 的值（用于处理借位）。

当 $q\_k \> 0$ 时，直接拼接到 $Q$；当 $q\_k \< 0$ 时，从 $Q$ 中借位（即切换到 $QM$ 拼接补码）。这种方法避免了最后使用全加法器进行减法运算。

## **4\. 算法流程总结**

1. **初始化**：  
   * 加载被除数至 $P$，除数至 $D$。  
   * 执行归一化，记录移位量。  
2. **迭代** (循环 $N/2$ 次)：  
   * **QDS**：根据 $4P$ 和 $D$ 的高位查表得到 $q \\in \\{-2, \-1, 0, 1, 2\\}$。  
   * **计算项生成**：生成 $-q \\cdot D$（利用移位和取反）。  
   * **余数更新**：$P \\leftarrow 4P \+ (-q \\cdot D)$。  
   * **商更新**：利用On-the-Fly逻辑更新 $Q$ 和 $QM$。  
3. **后处理**：  
   * 若最终余数 $P \< 0$，执行恢复操作（$P \\leftarrow P \+ D$，商减1）。  
   * 根据归一化移位量对余数进行反归一化。

## **5\. 性能与优化**

* **延迟**：主要取决于 QDS 查表延迟 \+ MUX 选择延迟 \+ CSA 加法延迟。  
* **面积**：相较于Radix-2，Radix-4的面积略有增加（需要生成 $2D$），但迭代次数减半，吞吐量翻倍。  
* **关键路径优化**：在高性能实现中，QDS通常与部分余数计算并行推测，或采用重叠执行（Overlapped execution）。

此设计逻辑提供了从理论公式到硬件映射的完整路径，适用于高性能微处理器的算术逻辑单元设计。