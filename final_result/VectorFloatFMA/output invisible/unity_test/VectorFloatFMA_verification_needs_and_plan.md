# VectorFloatFMA 验证需求与规划文档

## 1. 设计理解与验证目标

### 1.1 设计概述
VectorFloatFMA是一个执行RISC-V V扩展的向量浮点乘加融合单元，具有以下核心特性：
- **功能**：执行浮点乘加融合运算（FMA: a*b+c）
- **架构**：四周期流水线设计
- **精度支持**：FP16、FP32、FP64三种浮点格式
- **操作类型**：支持9种操作码（0-8），包括乘法、乘加、乘减等变体
- **特殊值处理**：支持NaN、无穷大、零等IEEE 754特殊值
- **舍入模式**：支持5种舍入模式（0-4）
- **异常标志**：输出20位的标志位信息

### 1.2 验证目标
验证VectorFloatFMA的功能正确性，确保：
1. **基本运算正确性**：各种操作码对应的运算结果符合预期
2. **多精度支持**：FP16/FP32/FP64格式的计算准确性
3. **舍入模式**：各种舍入模式下的结果符合IEEE 754标准
4. **特殊值处理**：NaN、Inf、零等特殊值的正确处理
5. **异常标志**：溢出、下溢、无效操作等标志位的正确性
6. **流水线行为**：四周期流水线的正确功能（非时序特性）

**注意**：本次验证仅关注功能正确性，不验证波形、接口时序等非功能性特征。

## 2. 接口与信号分析

### 2.1 输入信号
**主要测试信号**：
- `io_fp_a[63:0]`：源操作数vs2
- `io_fp_b[63:0]`：源操作数vs1
- `io_fp_c[63:0]`：源操作数vd
- `io_fire`：有效信号，为1时开始计算
- `io_fp_format[1:0]`：浮点格式（00=FP16, 01=FP32, 10=FP64, 11=无效）
- `io_op_code[3:0]`：操作码（0-8有效）
- `io_round_mode[2:0]`：舍入模式（0-4有效）

**固定为常量的信号**（测试中不变）：
- `io_is_vec = 1`
- `io_widen_a = 0`
- `io_widen_b = 0`
- `io_frs1 = 0`
- `io_is_frs1 = 0`
- `io_uop_idx = 0`
- `io_res_widening = 0`
- `io_fp_aIsFpCanonicalNAN = 0`
- `io_fp_bIsFpCanonicalNAN = 0`
- `io_fp_cIsFpCanonicalNAN = 0`

### 2.2 输出信号
- `io_fp_result[63:0]`：计算结果
- `io_fflags[19:0]`：异常标志位（包括溢出、下溢、无效操作、除零、不精确）

### 2.3 操作码映射

| opcode | 指令 | 计算公式 |
|--------|------|----------|
| 0000 | vfmul | vd = vs2 * vs1 |
| 0001 | vfmacc | vd = +(vs2 * vs1) + vd |
| 0010 | vfnmacc | vd = -(vs2 * vs1) - vd |
| 0011 | vfmsac | vd = +(vs2 * vs1) - vd |
| 0100 | vfnmsac | vd = -(vs2 * vs1) + vd |
| 0101 | vfmadd | vd = +(vs2 * vd) + vs1 |
| 0110 | vfnmadd | vd = -(vs2 * vd) - vs1 |
| 0111 | vfmsub | vd = +(vs2 * vd) - vs1 |
| 1000 | vfnmsub | vd = -(vs2 * vd) + vs1 |

**注意**：操作数顺序为vs2、vs1、vd，功能单元内部会根据op_code调换顺序。

## 3. 风险识别与边界条件

### 3.1 高风险区域
1. **特殊值处理**
   - NaN的传播和生成（如0*Inf）
   - 无穷大运算（Inf+Inf, Inf-Inf）
   - 零的符号处理（+0, -0）
   - 非规格化数（Subnormal numbers）

2. **舍入模式**
   - 不同舍入模式下的边界值
   - Tie-breaking情况（正好在中间的舍入）
   - 舍入导致的溢出/下溢

3. **异常标志**
   - 溢出（Overflow）：结果超出可表示范围
   - 下溢（Underflow）：结果小于最小正规格化数
   - 无效操作（Invalid）：如NaN运算
   - 不精确（Inexact）：舍入导致精度损失
   - 除零（Division by Zero）：虽然是乘加，但某些特殊情况可能触发

4. **操作码变体**
   - 符号翻转的正确性（nmacc, nmsac, nmadd, nmsub）
   - 操作数顺序调换（macc vs madd）
   - 乘法单独操作（opcode=0）

5. **精度转换**
   - FP16的范围限制（最小指数-14，最大指数15）
   - FP32和FP64的边界值
   - 不同格式下的特殊值表示

### 3.2 边界条件
1. **数值边界**
   - 最大/最小正规格化数
   - 最大/最小非规格化数
   - 零值（+0.0, -0.0）
   - 无穷大（+Inf, -Inf）
   - NaN（qNaN, sNaN）

2. **操作边界**
   - 有效操作码范围（0-8）
   - 无效操作码（9-15）
   - 有效舍入模式（0-4）
   - 无效舍入模式（5-7）
   - 有效浮点格式（0-2）
   - 无效浮点格式（3）

3. **流水线边界**
   - 连续输入（背靠背操作）
   - io_fire信号的控制

## 4. 验证策略与计划

### 4.1 验证方法论
采用**分层验证策略**：
1. **定向测试**：针对特定功能和边界条件
2. **随机测试**：大量随机输入覆盖状态空间
3. **参考模型对比**：使用Python/NumPy作为黄金参考
4. **覆盖率驱动**：通过代码覆盖率发现遗漏场景

### 4.2 测试分解计划

#### 阶段1：基础功能验证
- **目标**：验证各操作码的基本功能
- **测试内容**：
  - 每个操作码（0-8）的基本运算
  - 简单的正数运算
  - FP32格式作为基准
  - 默认舍入模式（RNE）
- **预期覆盖**：9种操作码 × 基本用例

#### 阶段2：多精度验证
- **目标**：验证FP16/FP32/FP64三种格式
- **测试内容**：
  - FP16：范围[-65504, 65504]，指数范围[-14, 15]
  - FP32：范围约±3.4e38，指数范围[-126, 127]
  - FP64：范围约±1.8e308，指数范围[-1022, 1023]
  - 每种格式的边界值测试
- **预期覆盖**：3种格式 × 9种操作 × 边界用例

#### 阶段3：舍入模式验证
- **目标**：验证IEEE 754的5种舍入模式
- **测试内容**：
  - RNE (0): Round to Nearest, ties to Even
  - RTZ (1): Round Towards Zero
  - RDN (2): Round Down (towards -∞)
  - RUP (3): Round Up (towards +∞)
  - RMM (4): Round to Nearest, ties to Max Magnitude
  - 重点测试tie-breaking情况
- **预期覆盖**：5种舍入模式 × 关键操作 × tie用例

#### 阶段4：特殊值验证
- **目标**：验证NaN、Inf、零等特殊值处理
- **测试内容**：
  - NaN传播：任何操作数为NaN → 结果为NaN
  - NaN生成：0*Inf, Inf-Inf → NaN
  - 无穷大运算：Inf*x, Inf+Inf, Inf-Inf
  - 零的符号：+0, -0及其运算
  - 非规格化数（Subnormal）
- **预期覆盖**：特殊值组合 × 9种操作

#### 阶段5：异常标志验证
- **目标**：验证fflags标志位的正确性
- **测试内容**：
  - 溢出标志（OF）：大数相乘或相加
  - 下溢标志（UF）：小数运算
  - 无效操作（NV）：如0*Inf
  - 不精确（NX）：舍入产生误差
  - 除零标志（DZ）：特殊情况
- **预期覆盖**：5类异常 × 触发场景

#### 阶段6：压力与随机测试
- **目标**：发现隐藏bug，提高覆盖率
- **测试内容**：
  - 大量随机输入组合
  - 边界值随机组合
  - 与参考模型对比
  - 代码覆盖率分析
- **预期覆盖**：高代码覆盖率（目标>90%）

### 4.3 测试用例设计原则
1. **等价类划分**：将输入空间划分为等价类，每类选代表值
2. **边界值分析**：测试边界和边界附近的值
3. **组合测试**：关键参数的正交组合
4. **错误推测**：基于经验预测易错点
5. **参考模型**：使用Python的浮点运算作为黄金参考

### 4.4 验证环境架构
```
测试框架：pytest + toffee
DUT接口：通过pickle_interface.so加载
参考模型：Python/NumPy实现IEEE 754运算
测试组织：按功能分模块，每个模块包含多个测试用例
断言策略：结果精确匹配或ULP（Unit in Last Place）容差
```

### 4.5 成功标准
1. **功能正确性**：所有定向测试通过
2. **覆盖率**：代码覆盖率 > 90%
3. **随机测试**：大规模随机测试通过率 > 99.9%
4. **Bug发现**：识别并记录所有设计缺陷
5. **文档完整**：测试用例、覆盖率报告、bug分析文档齐全

## 5. 潜在bug预测

基于对FMA单元的理解，可能存在以下bug：
1. **符号处理错误**：负数乘加的符号位错误
2. **舍入错误**：tie-breaking情况处理不当
3. **特殊值错误**：NaN/Inf的边界情况未正确处理
4. **溢出/下溢**：极限情况下的标志位错误
5. **操作数混淆**：操作码对应的操作数顺序错误
6. **精度错误**：不同浮点格式下的计算误差
7. **流水线数据冒险**：连续操作时的数据错误

**验证策略**：通过充分的测试用例触发这些潜在bug，测试失败时优先怀疑是设计问题而非测试问题。

## 6. 交付物清单

1. ✅ **验证规划文档**（本文档）
2. ⏳ **测试用例代码**：分模块的pytest测试集
3. ⏳ **参考模型**：Python实现的FMA参考模型
4. ⏳ **覆盖率报告**：代码覆盖率分析
5. ⏳ **Bug分析报告**：发现的bug及其根因分析
6. ⏳ **测试报告**：测试执行结果和统计

## 7. 时间规划

| 阶段 | 任务 | 预估工作量 |
|------|------|------------|
| 1 | 需求分析与规划 | 完成 ✓ |
| 2 | 测试环境搭建 | 后续 |
| 3 | 参考模型开发 | 后续 |
| 4 | 基础功能测试 | 后续 |
| 5 | 多精度测试 | 后续 |
| 6 | 舍入模式测试 | 后续 |
| 7 | 特殊值测试 | 后续 |
| 8 | 异常标志测试 | 后续 |
| 9 | 随机压力测试 | 后续 |
| 10 | Bug分析与报告 | 后续 |

## 8. 风险与应对

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| 参考模型不准确 | 误判bug | 使用多个参考源交叉验证 |
| 测试覆盖不足 | 遗漏bug | 使用覆盖率工具指导用例设计 |
| 特殊值理解偏差 | 错误断言 | 深入学习IEEE 754标准 |
| 流水线时序问题 | 验证困难 | 使用Step接口正确驱动流水线 |

---

**文档版本**：v1.0  
**创建日期**：2025-12-03  
**最后更新**：2025-12-03  
**作者**：AI验证工程师
