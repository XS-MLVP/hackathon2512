# VectorFloatFMA 基本信息文档

## 1. 芯片概述

**名称**：VectorFloatFMA（向量浮点乘加融合单元）

**功能**：执行RISC-V V扩展的向量浮点乘加融合运算（FMA: Fused Multiply-Add），支持多种精度格式的浮点乘加计算。

**架构特点**：
- 四周期流水线设计
- 支持多种浮点精度（FP16/FP32/FP64）
- 支持9种操作码变体
- 符合IEEE 754浮点标准

## 2. 芯片类型判定

**芯片类型**：时序电路（Sequential Circuit）

**判定依据**：
1. 具有时钟信号（clock）和复位信号（reset）
2. 采用四周期流水线架构，需要时钟驱动
3. 接口类定义中使用`xclock`和`Step()`方法进行时钟驱动
4. 输入有效信号`io_fire`控制数据进入流水线的时机

**驱动方式**：必须使用`Step()`接口驱动电路，每次Step推进一个时钟周期。

## 3. 输入输出端口分析

### 3.1 通用控制信号
| 端口名 | 位宽 | 方向 | 功能说明 |
|--------|------|------|----------|
| clock | 1 | 输入 | 时钟信号，驱动流水线 |
| reset | 1 | 输入 | 复位信号，初始化电路状态 |

### 3.2 主要功能输入信号
| 端口名 | 位宽 | 方向 | 功能说明 | 测试设置 |
|--------|------|------|----------|----------|
| io_fp_a | 64 | 输入 | 源操作数vs2（第一个浮点数） | 可变 |
| io_fp_b | 64 | 输入 | 源操作数vs1（第二个浮点数） | 可变 |
| io_fp_c | 64 | 输入 | 源操作数vd（第三个浮点数） | 可变 |
| io_fire | 1 | 输入 | 计算使能信号，为1时输入有效，开始计算 | 可变 |
| io_round_mode | 3 | 输入 | IEEE 754舍入模式（0-4有效） | 可变 |
| io_fp_format | 2 | 输入 | 浮点格式选择（00=FP16, 01=FP32, 10=FP64, 11=无效） | 可变 |
| io_op_code | 4 | 输入 | 操作码（0-8有效，指定乘加变体） | 可变 |

**操作数说明**：三个操作数的顺序固定为vs2、vs1、vd（对应io_fp_a、io_fp_b、io_fp_c），功能单元内部会根据op_code调换顺序。

### 3.3 固定配置输入信号（测试中不变）
| 端口名 | 位宽 | 方向 | 功能说明 | 测试设置值 |
|--------|------|------|----------|-----------|
| io_is_vec | 1 | 输入 | 向量模式标志 | 固定为1 |
| io_widen_a | 64 | 输入 | widen模式下的vs2扩展 | 固定为0 |
| io_widen_b | 64 | 输入 | widen模式下的vs1扩展 | 固定为0 |
| io_frs1 | 64 | 输入 | 浮点寄存器数据 | 固定为0 |
| io_is_frs1 | 1 | 输入 | 加数是否来自浮点寄存器 | 固定为0 |
| io_uop_idx | 1 | 输入 | widen时选择高/低半部分 | 固定为0 |
| io_res_widening | 1 | 输入 | widen指令标志 | 固定为0 |
| io_fp_aIsFpCanonicalNAN | 1 | 输入 | fp_a是否是标准NAN | 固定为0 |
| io_fp_bIsFpCanonicalNAN | 1 | 输入 | fp_b是否是标准NAN | 固定为0 |
| io_fp_cIsFpCanonicalNAN | 1 | 输入 | fp_c是否是标准NAN | 固定为0 |

### 3.4 输出信号
| 端口名 | 位宽 | 方向 | 功能说明 |
|--------|------|------|----------|
| io_fp_result | 64 | 输出 | 浮点计算结果（根据io_fp_format解释） |
| io_fflags | 20 | 输出 | 异常标志位（IEEE 754标准异常） |

**fflags标志位说明**（推测基于IEEE 754标准）：
- NV (Invalid Operation): 无效操作，如NaN运算
- DZ (Division by Zero): 除零（FMA中可能不常见）
- OF (Overflow): 溢出
- UF (Underflow): 下溢
- NX (Inexact): 不精确，舍入导致精度损失

## 4. 功能分类与功能点统计

### 4.1 功能分类

VectorFloatFMA的功能可分为以下几大类：

#### 分类1：基础运算类型（按操作码）
1. **单纯乘法**：vfmul（opcode=0）
2. **乘加类**：vfmacc（opcode=1）
3. **乘减类**：vfmsac（opcode=3）、vfmsub（opcode=7）
4. **负乘加类**：vfnmsac（opcode=4）、vfnmsub（opcode=8）
5. **负乘减类**：vfnmacc（opcode=2）、vfnmadd（opcode=6）
6. **特殊乘加类**：vfmadd（opcode=5，操作数顺序不同）

**小计**：9种操作码变体

#### 分类2：浮点精度支持
1. **FP16**（半精度，16位）
2. **FP32**（单精度，32位）
3. **FP64**（双精度，64位）

**小计**：3种浮点格式

#### 分类3：舍入模式
1. **RNE**（Round to Nearest, ties to Even，模式0）
2. **RTZ**（Round Towards Zero，模式1）
3. **RDN**（Round Down，模式2）
4. **RUP**（Round Up，模式3）
5. **RMM**（Round to Nearest, ties to Max Magnitude，模式4）

**小计**：5种舍入模式

#### 分类4：特殊值处理
1. **NaN处理**（qNaN, sNaN, NaN传播和生成）
2. **无穷大处理**（+Inf, -Inf及其运算）
3. **零值处理**（+0, -0及符号规则）
4. **非规格化数**（Subnormal numbers）
5. **最大/最小正规格化数**

**小计**：5类特殊值场景

#### 分类5：异常标志生成
1. **无效操作标志**（Invalid Operation）
2. **除零标志**（Division by Zero）
3. **溢出标志**（Overflow）
4. **下溢标志**（Underflow）
5. **不精确标志**（Inexact）

**小计**：5种异常标志

### 4.2 功能点统计

**基础功能点**：
- 操作码变体：9个
- 浮点格式：3个
- 舍入模式：5个
- 基础功能点 = 9 × 3 × 5 = **135个基础组合**

**扩展功能点**（考虑特殊值和边界）：
- 每种基础组合需测试：
  - 普通值：约5-10个典型用例
  - 边界值：约5-10个边界用例（最大/最小值等）
  - 特殊值：约10-20个特殊用例（NaN, Inf, 零等）
- 异常标志验证：每种异常×多种触发场景 = 约20-50个用例
- 流水线行为：连续操作、背靠背测试 = 约10-20个用例

**保守估计总功能点**：
- 基础功能组合：135个
- 每个组合的典型测试：10-20个用例
- 特殊场景和边界测试：100-200个
- 随机测试：1000+个

**预计测试用例总数**：**2000-3000个**（包括定向+随机）

### 4.3 关键功能点优先级

**P0（最高优先级）**：
1. 9种操作码的基本正确性（FP32, 默认舍入）
2. FP16/FP32/FP64三种格式的基本运算
3. NaN和Inf的正确处理
4. 溢出和下溢的标志位

**P1（高优先级）**：
1. 5种舍入模式的正确性
2. 零值符号处理
3. 非规格化数处理
4. 异常标志的完整性

**P2（中优先级）**：
1. 边界值的鲁棒性
2. 极限情况的稳定性
3. 流水线连续操作
4. 无效输入的处理（无效opcode, 无效format等）

## 5. 代码接口信息

### 5.1 DUT类定义
- **类名**：`DUTVectorFloatFMA`
- **父类**：继承自xspcomm框架
- **初始化**：支持波形导出和覆盖率收集

### 5.2 主要API方法
| 方法名 | 功能 | 用途 |
|--------|------|------|
| `Step(i)` | 推进i个时钟周期 | 驱动流水线执行 |
| `InitClock(name)` | 初始化时钟信号 | 时钟配置 |
| `SetWaveform(filename)` | 设置波形文件 | 调试和分析 |
| `SetCoverage(filename)` | 设置覆盖率文件 | 覆盖率收集 |
| `GetInternalSignal(name)` | 读取内部信号 | 深度调试 |
| `Finish()` | 结束仿真 | 资源清理 |

### 5.3 信号访问方式
- 直接访问：`dut.io_fp_a.value`、`dut.io_fp_result.value`
- 子端口分组：`dut.io.*`、`dut.io_fp.*`等
- 信号类型：使用`xsp.XPin`和`xsp.XData`封装

### 5.4 测试框架集成
- **测试框架**：pytest + toffee
- **DUT加载**：通过`libUT_VectorFloatFMA`动态库
- **信号驱动**：使用`XPort`和`XClock`机制
- **波形导出**：支持VCD/FST等格式

## 6. 验证关键点

### 6.1 时序要求
- **流水线深度**：4周期
- **输入使能**：`io_fire=1`时输入有效
- **输出延迟**：输入后4个周期出结果
- **连续操作**：需要测试背靠背输入

### 6.2 数据格式要求
- **64位输入**：无论何种格式，输入都是64位
- **格式解释**：根据`io_fp_format`解释有效位
  - FP16：使用低16位
  - FP32：使用低32位
  - FP64：使用全64位
- **结果格式**：输出也是64位，按相同格式解释

### 6.3 特殊处理要求
- **操作数顺序**：虽然输入是固定的vs2、vs1、vd，但某些opcode会内部调换
- **舍入行为**：必须严格符合IEEE 754标准
- **异常优先级**：多个异常同时发生时的标志位设置

## 7. 测试注意事项

1. **必须使用Step驱动**：即使是组合逻辑，也要用Step接口（实际是时序电路）
2. **流水线延迟**：输入后需要等待4个Step才能读取结果
3. **参考模型**：需要实现符合IEEE 754的浮点运算参考模型
4. **位级精确**：结果需要位级精确匹配，不能有任何偏差
5. **覆盖率**：使用覆盖率工具确保测试充分性
6. **Bug假设**：测试失败优先怀疑DUT有bug，而非测试有误

## 8. 预期验证难点

1. **IEEE 754复杂性**：浮点标准的细节繁多，容易遗漏
2. **特殊值组合**：NaN/Inf/Zero的各种组合需要仔细考虑
3. **舍入模式**：不同舍入模式的tie-breaking规则易错
4. **精度差异**：FP16/32/64的范围和精度差异大
5. **异常标志**：多个异常同时触发时的行为
6. **流水线时序**：连续输入时的数据依赖关系

---

**文档版本**：v1.0  
**创建日期**：2025-12-03  
**最后更新**：2025-12-03  
**作者**：AI验证工程师
